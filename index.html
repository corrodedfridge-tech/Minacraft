<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minacraft</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'VT323', monospace;
            user-select: none;
            background-color: #121212;
            touch-action: none; 
        }

        /* --- MAIN MENU STYLES --- */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
        }

        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 90;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(2px);
        }

        #pause-menu h2 {
            color: #fff;
            font-size: 40px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
        }

        .logo-container {
            position: relative;
            margin-bottom: 40px;
            transform: scale(1.0); 
        }

        .title-image {
            image-rendering: pixelated;
            max-width: 80vw;
            height: auto;
            display: block;
        }

        .splash-text {
            position: absolute;
            bottom: 0;
            right: -20px;
            font-size: 32px;
            color: #FFFF55;
            transform: rotate(-20deg);
            animation: splashPulse 0.5s infinite alternate;
            text-shadow: 2px 2px 0px #3f3f00;
            font-weight: bold;
            z-index: 10;
            white-space: nowrap;
        }

        @keyframes splashPulse {
            from { transform: rotate(-20deg) scale(1); }
            to { transform: rotate(-20deg) scale(1.1); }
        }

        .mc-button {
            width: 400px;
            max-width: 80vw;
            height: 40px;
            background-color: #999;
            border: 2px solid #000;
            border-top-color: #fff;
            border-left-color: #fff;
            border-bottom-color: #555;
            border-right-color: #555;
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 24px;
            text-shadow: 2px 2px 0 #333;
            cursor: pointer;
            margin-bottom: 10px;
            position: relative;
            image-rendering: pixelated;
        }

        .mc-button:hover {
            background-color: #7d8aff;
            color: #ffffa0;
            text-shadow: 2px 2px 0 #3a3a00;
            border-color: #000;
        }

        .mc-button:active {
            background-color: #555;
            border-top-color: #555;
            border-left-color: #555;
            border-bottom-color: #fff;
            border-right-color: #fff;
        }

        .version-text { position: absolute; bottom: 5px; left: 5px; color: #fff; font-size: 16px; font-family: sans-serif; }
        .copyright-text { position: absolute; bottom: 5px; right: 5px; color: #fff; font-size: 16px; font-family: sans-serif; }

        /* --- HUD --- */
        #game-ui { display: none; }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #mining-progress {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: white;
            opacity: 0;
        }

        #hud {
            position: absolute;
            bottom: 80px; 
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        #health-bar-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #333;
            display: flex;
        }
        
        .heart {
            flex: 1;
            background-color: #ff3333;
            margin: 1px;
            border: 1px solid #500;
        }
        .heart.lost { background-color: transparent; border: none; }
        
        #toolbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            background-color: rgba(0,0,0,0.3);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .slot.active { border-color: white; background-color: rgba(255,255,255,0.1); }
        .slot-icon {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            font-weight: bold;
        }

        #mobile-controls {
            display: none;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 20;
        }

        .touch-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.4); }

        #dpad { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; }
        #btn-up { top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-down { bottom: 0; left: 50px; width: 50px; height: 50px; }
        #btn-left { top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-right { top: 50px; right: 0; width: 50px; height: 50px; }
        #action-buttons { position: absolute; bottom: 20px; right: 20px; width: 150px; height: 150px; }
        #btn-jump { bottom: 40px; right: 40px; width: 70px; height: 70px; border-radius: 50%; }

        @media (max-width: 768px) {
            #hud { top: 10px; bottom: auto; left: 10px; font-size: 14px; }
            #health-bar-container { top: 10px; bottom: auto; right: 10px; left: auto; transform: none; width: 150px; }
            #mobile-controls { display: block; }
            #toolbar { bottom: 5px; transform: translateX(-50%) scale(0.8); }
        }
    </style>
</head>
<body>

    <div id="main-menu">
        <div class="logo-container">
            <img src="MINACRAFT.png" class="title-image" alt="MINACRAFT">
            <div class="splash-text">uhh</div>
        </div>
        <button class="mc-button" id="btn-generate">Generate World</button>
        <div class="version-text">Minacraft JS 1.10 (Cave Fixes & Hand)</div>
        <div class="copyright-text">Copyright not Mojang AB</div>
    </div>

    <div id="pause-menu">
        <h2>Game Menu</h2>
        <button class="mc-button" id="btn-resume">Back to Game</button>
        <button class="mc-button" id="btn-disconnect">Disconnect</button>
    </div>

    <div id="game-ui">
        <div id="crosshair">
            <div id="mining-progress"></div>
        </div>
        <div id="health-bar-container" id="healthBar"></div>
        <div id="hud">
            FPS: <span id="fps">0</span><br>
            Coords: <span id="coords">0, 0, 0</span><br>
            Time: <span id="time">00:00</span>
        </div>
        <div id="toolbar">
            <div class="slot active" id="slot0"></div>
            <div class="slot" id="slot1"></div>
            <div class="slot" id="slot2"></div>
            <div class="slot" id="slot3"></div>
            <div class="slot" id="slot4"></div>
            <div class="slot" id="slot5"></div>
            <div class="slot" id="slot6"></div>
        </div>
        
        <div id="mobile-controls">
            <div id="dpad">
                <div class="touch-btn" id="btn-up"></div>
                <div class="touch-btn" id="btn-down"></div>
                <div class="touch-btn" id="btn-left"></div>
                <div class="touch-btn" id="btn-right"></div>
            </div>
            <div id="action-buttons">
                <div class="touch-btn" id="btn-jump"></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let inGame = false;
        let isPaused = false;

        // --- CONFIG ---
        const CHUNK_SIZE = 16;
        const CHUNK_HEIGHT = 128; 
        const RENDER_DISTANCE = 4;
        const WATER_LEVEL = 60; 
        const SNOW_LEVEL = 105; 
        
        // Physics
        const WALK_SPEED = 20.0; 
        const RUN_SPEED = 35.0;
        const SWIM_SPEED = 10.0;
        const JUMP_FORCE = 11.0;
        const SWIM_UP_FORCE = 8.0;
        const GRAVITY = 32.0;
        const WATER_GRAVITY = 5.0;
        const DRAG = 8.0; 
        const WATER_DRAG = 4.0;
        const PLAYER_RADIUS = 0.35;
        const PLAYER_HEIGHT = 1.8;
        const EYE_HEIGHT = 1.62;

        const BLOCKS = {
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, BEDROCK: 6, WATER: 7, SAND: 8, SNOW: 9
        };

        const BLOCK_HARDNESS = {
            [BLOCKS.GRASS]: 0.5, [BLOCKS.DIRT]: 0.5, [BLOCKS.STONE]: 1.2, 
            [BLOCKS.WOOD]: 0.8, [BLOCKS.LEAVES]: 0.2, [BLOCKS.BEDROCK]: Infinity,
            [BLOCKS.WATER]: Infinity, [BLOCKS.SAND]: 0.5, [BLOCKS.SNOW]: 0.5
        };

        const TEXTURE_COLORS = {
            [BLOCKS.GRASS]: { top: '#5B8D37', side: '#4A6F28', bottom: '#6D4F35', display: '#5B8D37' },
            [BLOCKS.DIRT]: { all: '#6D4F35', display: '#6D4F35' },
            [BLOCKS.STONE]: { all: '#707070', display: '#707070' },
            [BLOCKS.WOOD]: { side: '#5C3A21', top: '#8B5A2B', bottom: '#8B5A2B', display: '#5C3A21' },
            [BLOCKS.LEAVES]: { all: '#3A6B29', display: '#3A6B29' },
            [BLOCKS.BEDROCK]: { all: '#222222', display: '#222222' },
            [BLOCKS.SAND]: { all: '#d6cf94', display: '#d6cf94' }, 
            [BLOCKS.WATER]: { all: '#0060cc', display: '#0060cc' },
            [BLOCKS.SNOW]: { all: '#FFFFFF', display: '#FFFFFF' }
        };

        let timeOfDay = 0.2; 
        const daySpeed = 1.0 / 600.0; 
        const daySkyColor = new THREE.Color(0x87CEEB);
        const nightSkyColor = new THREE.Color(0x0A0A20);
        const dayFogColor = new THREE.Color(0x87CEEB);
        const nightFogColor = new THREE.Color(0x0A0A20);
        const underwaterSkyColor = new THREE.Color(0x001133);
        const underwaterFogColor = new THREE.Color(0x001133); 

        const INVENTORY_SIZE = 7;
        let inventory = Array(INVENTORY_SIZE).fill(null);
        let selectedSlot = 0;

        function updateInventoryUI() {
            for(let i=0; i<INVENTORY_SIZE; i++) {
                const el = document.getElementById('slot'+i);
                el.innerHTML = ''; 
                if (inventory[i]) {
                    const color = TEXTURE_COLORS[inventory[i].type].display;
                    const icon = document.createElement('div');
                    icon.className = 'slot-icon';
                    icon.style.backgroundColor = color;
                    const count = document.createElement('div');
                    count.className = 'slot-count';
                    count.innerText = inventory[i].count;
                    el.appendChild(icon);
                    el.appendChild(count);
                }
                if (i === selectedSlot) el.classList.add('active');
                else el.classList.remove('active');
            }
        }

        function addToInventory(blockType) {
            if(blockType === BLOCKS.WATER) return;
            for(let i=0; i<INVENTORY_SIZE; i++) {
                if(inventory[i] && inventory[i].type === blockType) {
                    inventory[i].count++;
                    updateInventoryUI();
                    return;
                }
            }
            for(let i=0; i<INVENTORY_SIZE; i++) {
                if(!inventory[i]) {
                    inventory[i] = { type: blockType, count: 1 };
                    updateInventoryUI();
                    return;
                }
            }
        }

        function removeFromInventory() {
            if (!inventory[selectedSlot]) return false;
            inventory[selectedSlot].count--;
            if (inventory[selectedSlot].count <= 0) inventory[selectedSlot] = null;
            updateInventoryUI();
            return true;
        }

        let maxHealth = 10;
        let currentHealth = 10;
        let highestY = 0;

        function initHealth() {
            const container = document.getElementById('health-bar-container');
            container.innerHTML = '';
            for(let i=0; i<maxHealth; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.id = 'heart-'+i;
                container.appendChild(heart);
            }
        }
        initHealth();

        function takeDamage(amount) {
            currentHealth = Math.max(0, currentHealth - amount);
            for(let i=0; i<maxHealth; i++) {
                const heart = document.getElementById('heart-'+i);
                if (i >= currentHealth) heart.classList.add('lost');
                else heart.classList.remove('lost');
            }
            document.body.style.boxShadow = "inset 0 0 50px red";
            setTimeout(() => document.body.style.boxShadow = "none", 200);

            if (currentHealth <= 0) {
                respawnPlayer();
                currentHealth = maxHealth;
                inventory = Array(INVENTORY_SIZE).fill(null);
                updateInventoryUI();
                initHealth();
            }
        }

        class SimplexNoise {
            constructor() {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 0; i < 256; i++) {
                    const r = Math.floor(Math.random() * 256);
                    [this.p[i], this.p[r]] = [this.p[r], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }
            dot(g, x, y) { return g[0] * x + g[1] * y; }
            dot3(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
            noise2D(xin, yin) {
                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                let n0, n1, n2;
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                let i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii + this.perm[jj]] % 12;
                const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
                const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * this.dot(grad3[gi0], x0, y0); }
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * this.dot(grad3[gi1], x1, y1); }
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * this.dot(grad3[gi2], x2, y2); }
                return 70.0 * (n0 + n1 + n2);
            }
            noise3D(x, y, z) {
                let n0, n1, n2, n3; 
                const F3 = 1.0/3.0;
                const s = (x+y+z)*F3;
                const i = Math.floor(x+s);
                const j = Math.floor(y+s);
                const k = Math.floor(z+s);
                const G3 = 1.0/6.0;
                const t = (i+j+k)*G3;
                const X0 = i-t;
                const Y0 = j-t;
                const Z0 = k-t;
                const x0 = x-X0;
                const y0 = y-Y0;
                const z0 = z-Z0;
                let i1, j1, k1;
                let i2, j2, k2;
                if(x0>=y0) {
                    if(y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0*G3;
                const y2 = y0 - j2 + 2.0*G3;
                const z2 = z0 - k2 + 2.0*G3;
                const x3 = x0 - 1.0 + 3.0*G3;
                const y3 = y0 - 1.0 + 3.0*G3;
                const z3 = z0 - 1.0 + 3.0*G3;
                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                const getGrad = (ii,jj,kk) => grad3[this.perm[(ii&255)+this.perm[(jj&255)+this.perm[kk&255]]] % 12];
                let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot3(getGrad(i,j,k), x0, y0, z0); }
                let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot3(getGrad(i+i1,j+j1,k+k1), x1, y1, z1); }
                let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot3(getGrad(i+i2,j+j2,k+k2), x2, y2, z2); }
                let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                if(t3<0) n3 = 0.0; else { t3 *= t3; n3 = t3 * t3 * this.dot3(getGrad(i+1,j+1,k+1), x3, y3, z3); }
                return 32.0*(n0 + n1 + n2 + n3);
            }
        }

        function createTexture(colorStr) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorStr;
            ctx.fillRect(0, 0, 64, 64);
            for(let i=0; i<400; i++) {
                const x = Math.random() * 64;
                const y = Math.random() * 64;
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                ctx.fillRect(x, y, 2, 2);
            }
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.strokeRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const waterCanvas = document.createElement('canvas');
        waterCanvas.width = 64;
        waterCanvas.height = 64;
        const waterCtx = waterCanvas.getContext('2d');
        const waterTexture = new THREE.CanvasTexture(waterCanvas);
        waterTexture.magFilter = THREE.NearestFilter;
        
        waterTexture.wrapS = THREE.RepeatWrapping;
        waterTexture.wrapT = THREE.RepeatWrapping;

        function updateWaterTexture() {
            waterCtx.fillStyle = '#0055AA'; 
            waterCtx.fillRect(0, 0, 64, 64);
            waterTexture.needsUpdate = true;
        }
        updateWaterTexture(); 

        const scene = new THREE.Scene();
        scene.background = daySkyColor.clone(); 
        scene.fog = new THREE.Fog(dayFogColor.clone(), 10, (RENDER_DISTANCE * CHUNK_SIZE) - 5);

        const playerCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const menuCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PLAYER HAND
        const handGroup = new THREE.Group();
        const handGeo = new THREE.BoxGeometry(0.2, 0.2, 0.6);
        const handMat = new THREE.MeshLambertMaterial({ color: 0xeebb99 }); // Skin color
        const handMesh = new THREE.Mesh(handGeo, handMat);
        handMesh.position.set(0.4, -0.3, -0.8); 
        handMesh.rotation.x = 0.3;
        handMesh.rotation.y = -0.1;
        handGroup.add(handMesh);
        playerCamera.add(handGroup);
        scene.add(playerCamera); // Add camera to scene to render hand

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        const sunGeo = new THREE.SphereGeometry(8, 16, 16);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFFCC });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        const moonGeo = new THREE.SphereGeometry(6, 16, 16);
        const moonMat = new THREE.MeshBasicMaterial({ color: 0xAAAAAA });
        const moon = new THREE.Mesh(moonGeo, moonMat);
        scene.add(moon);

        const cloudGeo = new THREE.BoxGeometry(1, 1, 1);
        const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.8, transparent: true });
        const clouds = new THREE.Group();
        scene.add(clouds);

        function generateClouds() {
            for(let i=0; i<20; i++) {
                const cloud = new THREE.Mesh(cloudGeo, cloudMat);
                cloud.scale.set(10 + Math.random()*20, 2 + Math.random()*2, 8 + Math.random()*10);
                cloud.position.set(
                    (Math.random()-0.5) * 300,
                    110 + Math.random() * 10, 
                    (Math.random()-0.5) * 300
                );
                clouds.add(cloud);
            }
        }
        generateClouds();

        const highlightMesh = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.BoxGeometry(1.001, 1.001, 1.001)),
            new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
        );
        highlightMesh.visible = false;
        scene.add(highlightMesh);

        const controls = new PointerLockControls(playerCamera, document.body);
        const mainMenu = document.getElementById('main-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const gameUI = document.getElementById('game-ui');
        const btnGenerate = document.getElementById('btn-generate');
        const btnResume = document.getElementById('btn-resume');
        const btnDisconnect = document.getElementById('btn-disconnect');

        btnGenerate.addEventListener('click', () => {
            mainMenu.style.display = 'none';
            gameUI.style.display = 'block';
            inGame = true;
            isPaused = false;
            respawnPlayer(); 
            controls.lock();
        });

        btnResume.addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            isPaused = false;
            controls.lock();
        });

        btnDisconnect.addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            gameUI.style.display = 'none';
            mainMenu.style.display = 'flex';
            inGame = false;
            isPaused = false;
            playerCamera.position.set(0,50,0);
        });

        controls.addEventListener('lock', () => {
            if(inGame) {
                isPaused = false;
                pauseMenu.style.display = 'none';
            }
        });

        controls.addEventListener('unlock', () => {
            if(inGame) {
                isPaused = true;
                pauseMenu.style.display = 'flex';
            }
        });

        const materials = {};
        Object.keys(TEXTURE_COLORS).forEach(type => {
            if(type == BLOCKS.WATER) return; 
            const def = TEXTURE_COLORS[type];
            if(def.all) {
                materials[type] = new THREE.MeshLambertMaterial({ map: createTexture(def.all) });
            } else {
                materials[type] = [
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.top) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.top) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                ];
            }
        });
        
        materials[BLOCKS.WATER] = new THREE.MeshLambertMaterial({ 
            map: waterTexture, 
            transparent: true, 
            opacity: 0.8, 
            side: THREE.DoubleSide,
        });

        const noise = new SimplexNoise();
        const chunks = new Map(); 

        function getBlock(x, y, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const localX = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const key = `${cx},${cz}`;
            if (!chunks.has(key)) return BLOCKS.AIR;
            const chunk = chunks.get(key);
            if (y < 0 || y >= CHUNK_HEIGHT) return BLOCKS.AIR;
            return chunk.data[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
        }

        function setBlock(x, y, z, id) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const localX = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const key = `${cx},${cz}`;
            if (chunks.has(key)) {
                const chunk = chunks.get(key);
                if (y >= 0 && y < CHUNK_HEIGHT) {
                    chunk.data[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = id;
                    updateChunkGeometry(cx, cz);
                    if (localX === 0) updateChunkGeometry(cx - 1, cz);
                    if (localX === CHUNK_SIZE - 1) updateChunkGeometry(cx + 1, cz);
                    if (localZ === 0) updateChunkGeometry(cx, cz - 1);
                    if (localZ === CHUNK_SIZE - 1) updateChunkGeometry(cx, cz + 1);
                }
            }
        }

        function generateChunkData(cx, cz) {
            const data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT);
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const wx = cx * CHUNK_SIZE + x;
                    const wz = cz * CHUNK_SIZE + z;
                    
                    let continentalness = noise.noise2D(wx / 400, wz / 400); 
                    let peaks = noise.noise2D(wx / 50, wz / 50);
                    
                    let baseHeight = 40;
                    if (continentalness > 0.2) {
                        baseHeight += (continentalness - 0.2) * 60 + (peaks + 1) * 10;
                    } else {
                        baseHeight += continentalness * 20; 
                    }
                    
                    let surfaceHeight = Math.floor(baseHeight);
                    surfaceHeight = Math.max(5, Math.min(CHUNK_HEIGHT - 5, surfaceHeight));

                    let snowNoise = noise.noise2D(wx / 10, wz / 10) * 3;

                    for (let y = 0; y < CHUNK_HEIGHT; y++) {
                        let type = BLOCKS.AIR;
                        
                        let tentativeType = BLOCKS.AIR;
                        if (y === 0) { 
                            tentativeType = BLOCKS.BEDROCK; 
                        } else if (y <= surfaceHeight) {
                            // SOLID UNDERGROUND
                            if (y < surfaceHeight - 3) {
                                tentativeType = BLOCKS.STONE;
                            } 
                            // SURFACE
                            else {
                                if (y >= SNOW_LEVEL + snowNoise) {
                                    tentativeType = BLOCKS.SNOW;
                                } else if (y <= WATER_LEVEL + 2) {
                                    // DEEP SAND LOGIC
                                    if (y >= surfaceHeight - 3) {
                                         tentativeType = BLOCKS.SAND;
                                    } else {
                                         tentativeType = BLOCKS.STONE;
                                    }
                                } else {
                                    tentativeType = BLOCKS.GRASS;
                                }
                            }
                        } else if (y <= WATER_LEVEL) {
                            tentativeType = BLOCKS.WATER;
                        }

                        // Caves (Only in STONE and above WATER_LEVEL)
                        let isCave = false;
                        if (tentativeType === BLOCKS.STONE && y > WATER_LEVEL) {
                             if (noise.noise3D(wx/15, y/15, wz/15) > 0.6) isCave = true;
                             if (noise.noise3D(wx/30, y/30, wz/30) > 0.75) isCave = true;
                        }

                        if (isCave) {
                            type = BLOCKS.AIR;
                        } else {
                            type = tentativeType;
                        }

                        data[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;
                    }

                    // Trees
                    const surfIndex = x + z * CHUNK_SIZE + surfaceHeight * CHUNK_SIZE * CHUNK_SIZE;
                    if (surfIndex < data.length) {
                        const surfBlock = data[surfIndex];
                        if (surfBlock === BLOCKS.GRASS && surfaceHeight > WATER_LEVEL) {
                            if (Math.random() < 0.008) {
                                const h = surfaceHeight + 1;
                                for(let i=0; i<5; i++) { if(h+i < CHUNK_HEIGHT) data[x + z * CHUNK_SIZE + (h+i) * CHUNK_SIZE * CHUNK_SIZE] = BLOCKS.WOOD; }
                                for(let lx = Math.max(0, x-2); lx <= Math.min(CHUNK_SIZE-1, x+2); lx++) {
                                    for(let lz = Math.max(0, z-2); lz <= Math.min(CHUNK_SIZE-1, z+2); lz++) {
                                        for(let ly=h+3; ly<=h+5; ly++) {
                                            if (ly >= CHUNK_HEIGHT) continue;
                                            const idx = lx + lz * CHUNK_SIZE + ly * CHUNK_SIZE * CHUNK_SIZE;
                                            if (data[idx] === BLOCKS.AIR) data[idx] = BLOCKS.LEAVES;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return data;
        }

        function updateChunkGeometry(cx, cz) {
            const key = `${cx},${cz}`;
            if (!chunks.has(key)) return;
            const chunk = chunks.get(key);
            const instances = {};
            const dummy = new THREE.Object3D();

            const waterGeometry = new THREE.BufferGeometry();
            const waterPositions = [];
            const waterNormals = [];
            const waterUVs = [];
            const waterFaces = [];

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    for (let y = 0; y < CHUNK_HEIGHT; y++) {
                        const type = chunk.data[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
                        if (type === BLOCKS.AIR) continue;
                        
                        const wx = cx * CHUNK_SIZE + x;
                        const wz = cz * CHUNK_SIZE + z;
                        
                        if (type === BLOCKS.WATER) {
                            if (getBlock(wx, y + 1, wz) === BLOCKS.AIR) {
                                const v0 = new THREE.Vector3(wx, y + 1, wz);
                                const v1 = new THREE.Vector3(wx + 1, y + 1, wz);
                                const v2 = new THREE.Vector3(wx + 1, y + 1, wz + 1);
                                const v3 = new THREE.Vector3(wx, y + 1, wz + 1);
                                waterPositions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z);
                                const offset = waterPositions.length / 3 - 4;
                                waterFaces.push(offset + 0, offset + 1, offset + 2, offset + 0, offset + 2, offset + 3);
                                for(let i=0; i<4; i++) waterNormals.push(0, 1, 0);
                                const uvScale = 0.2; 
                                waterUVs.push(wx * uvScale, wz * uvScale);
                                waterUVs.push((wx+1) * uvScale, wz * uvScale);
                                waterUVs.push((wx+1) * uvScale, (wz+1) * uvScale);
                                waterUVs.push(wx * uvScale, (wz+1) * uvScale);
                            }
                        } else { 
                            const exposed = 
                                getBlock(wx+1, y, wz) === BLOCKS.AIR || getBlock(wx-1, y, wz) === BLOCKS.AIR ||
                                getBlock(wx, y+1, wz) === BLOCKS.AIR || getBlock(wx, y-1, wz) === BLOCKS.AIR ||
                                getBlock(wx, y, wz+1) === BLOCKS.AIR || getBlock(wx, y, wz-1) === BLOCKS.AIR ||
                                getBlock(wx, y+1, wz) === BLOCKS.WATER;

                            if (exposed) {
                                if (!instances[type]) instances[type] = [];
                                dummy.position.set(wx + 0.5, y + 0.5, wz + 0.5);
                                dummy.updateMatrix();
                                instances[type].push(dummy.matrix.clone());
                            }
                        }
                    }
                }
            }
            
            const chunkGroup = new THREE.Group();
            Object.keys(instances).forEach(type => {
                const count = instances[type].length;
                if(count === 0) return;
                const mesh = new THREE.InstancedMesh(new THREE.BoxGeometry(1,1,1), materials[type], count);
                instances[type].forEach((mat, i) => mesh.setMatrixAt(i, mat));
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                chunkGroup.add(mesh);
            });

            if (waterPositions.length > 0) {
                waterGeometry.setAttribute('position', new THREE.Float32BufferAttribute(waterPositions, 3));
                waterGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(waterNormals, 3));
                waterGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(waterUVs, 2));
                waterGeometry.setIndex(waterFaces);
                const waterMesh = new THREE.Mesh(waterGeometry, materials[BLOCKS.WATER]);
                chunkGroup.add(waterMesh);
            }
            
            if (chunk.mesh) scene.remove(chunk.mesh);
            chunk.mesh = chunkGroup;
            scene.add(chunkGroup);
        }

        function updateChunks() {
            const px = Math.floor(playerPos.x / CHUNK_SIZE);
            const pz = Math.floor(playerPos.z / CHUNK_SIZE);
            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const cx = px + x;
                    const cz = pz + z;
                    const key = `${cx},${cz}`;
                    if (!chunks.has(key)) {
                        chunks.set(key, { data: generateChunkData(cx, cz), mesh: null });
                        updateChunkGeometry(cx, cz);
                    }
                }
            }
            for (const [key, chunk] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - px) > RENDER_DISTANCE + 1 || Math.abs(cz - pz) > RENDER_DISTANCE + 1) {
                    if (chunk.mesh) scene.remove(chunk.mesh);
                    chunks.delete(key);
                }
            }
        }

        const particleGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const particles = [];
        function spawnParticles(hit) {
            let color = '#888888';
            if (TEXTURE_COLORS[hit.id]) color = TEXTURE_COLORS[hit.id].display || TEXTURE_COLORS[hit.id].all;
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const dx = hit.x - hit.px;
            const dy = hit.y - hit.py;
            const dz = hit.z - hit.pz;
            const baseX = hit.x + 0.5 - (dx * 0.5);
            const baseY = hit.y + 0.5 - (dy * 0.5);
            const baseZ = hit.z + 0.5 - (dz * 0.5);
            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(particleGeo, mat);
                mesh.position.set(baseX + (Math.random()-0.5)*0.8, baseY + (Math.random()-0.5)*0.8, baseZ + (Math.random()-0.5)*0.8);
                mesh.userData = {
                    vel: new THREE.Vector3((Math.random() - 0.5) * 4 + dx*2, (Math.random() - 0.5) * 4 + dy*2, (Math.random() - 0.5) * 4 + dz*2),
                    life: 0.5 + Math.random() * 0.3
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }
        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.life -= dt * 2;
                if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); } 
                else {
                    p.userData.vel.y -= 25 * dt;
                    p.position.addScaledVector(p.userData.vel, dt);
                    p.rotation.x += dt * 15;
                    p.scale.setScalar(p.userData.life);
                }
            }
        }

        const playerPos = new THREE.Vector3(0, 50, 0); 
        const velocity = new THREE.Vector3();
        let onGround = false;
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        let mouse = { left: false, right: false };
        let isMining = false;
        let miningTime = 0;
        let currentMineBlock = null;

        document.addEventListener('keydown', (e) => {
            if(isPaused) {
                if(e.key === 'Escape') { 
                    isPaused = false;
                    pauseMenu.style.display = 'none';
                    controls.lock();
                }
                return; 
            }
            switch(e.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': keys.space = true; break;
                case 'ShiftLeft': keys.shift = true; break;
                case 'Digit1': selectedSlot = 0; updateInventoryUI(); break;
                case 'Digit2': selectedSlot = 1; updateInventoryUI(); break;
                case 'Digit3': selectedSlot = 2; updateInventoryUI(); break;
                case 'Digit4': selectedSlot = 3; updateInventoryUI(); break;
                case 'Digit5': selectedSlot = 4; updateInventoryUI(); break;
                case 'Digit6': selectedSlot = 5; updateInventoryUI(); break;
                case 'Digit7': selectedSlot = 6; updateInventoryUI(); break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': false; break;
                case 'Space': keys.space = false; break;
                case 'ShiftLeft': keys.shift = false; break;
            }
        });
        document.addEventListener('mousedown', (e) => { 
            if (!controls.isLocked) return; 
            if (e.button === 0) { 
                mouse.left = true; isMining = true; miningTime = 0; 
                // Hand Swing Animation
                let swingProgress = 0;
                const swingInterval = setInterval(() => {
                    swingProgress += 0.2;
                    handMesh.rotation.x = 0.3 - Math.sin(swingProgress * Math.PI) * 0.5;
                    handMesh.rotation.z = Math.sin(swingProgress * Math.PI) * 0.2;
                    if (swingProgress >= 1) {
                        clearInterval(swingInterval);
                        handMesh.rotation.x = 0.3;
                        handMesh.rotation.z = 0;
                    }
                }, 30);
            } 
            if (e.button === 2) { const hit = raycast(); if (hit) placeBlock(hit); } 
        });
        document.addEventListener('mouseup', (e) => { if (e.button === 0) { mouse.left = false; isMining = false; miningTime = 0; resetMiningUI(); } });

        // Touch Buttons Logic
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnJump = document.getElementById('btn-jump');

        const addTouch = (elem, key) => {
            elem.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
            elem.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
        };
        addTouch(btnUp, 'w');
        addTouch(btnDown, 's');
        addTouch(btnLeft, 'a');
        addTouch(btnRight, 'd');
        addTouch(btnJump, 'space');

        function respawnPlayer() {
            let found = false;
            for(let r=0; r<5; r++) {
                for(let i=-r; i<=r; i++) {
                    for(let j=-r; j<=r; j++) {
                       if(!chunks.has(`${i},${j}`)) {
                           chunks.set(`${i},${j}`, { data: generateChunkData(i, j), mesh: null });
                       }
                       const chunk = chunks.get(`${i},${j}`);
                       const localX = CHUNK_SIZE/2;
                       const localZ = CHUNK_SIZE/2;
                       let y = CHUNK_HEIGHT - 1;
                       while(y > 0 && chunk.data[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] === BLOCKS.AIR) y--;
                       const block = chunk.data[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
                       if(block !== BLOCKS.WATER && y > WATER_LEVEL) {
                           playerPos.set(i*CHUNK_SIZE + localX, y + 2, j*CHUNK_SIZE + localZ);
                           velocity.set(0,0,0);
                           found = true;
                           break;
                       }
                    }
                    if(found) break;
                }
                if(found) break;
            }
            if(!found) {
                playerPos.set(0, 120, 0); 
                velocity.set(0,0,0);
            }
        }

        function raycast() {
            const start = new THREE.Vector3(playerPos.x, playerPos.y + EYE_HEIGHT, playerPos.z);
            const dir = new THREE.Vector3();
            playerCamera.getWorldDirection(dir);
            let x = Math.floor(start.x), y = Math.floor(start.y), z = Math.floor(start.z);
            const stepX = Math.sign(dir.x), stepY = Math.sign(dir.y), stepZ = Math.sign(dir.z);
            const tDeltaX = stepX !== 0 ? Math.abs(1 / dir.x) : Infinity;
            const tDeltaY = stepY !== 0 ? Math.abs(1 / dir.y) : Infinity;
            const tDeltaZ = stepZ !== 0 ? Math.abs(1 / dir.z) : Infinity;
            let tMaxX = (stepX > 0) ? (Math.floor(start.x) + 1 - start.x) * tDeltaX : (start.x - Math.floor(start.x)) * tDeltaX;
            let tMaxY = (stepY > 0) ? (Math.floor(start.y) + 1 - start.y) * tDeltaY : (start.y - Math.floor(start.y)) * tDeltaY;
            let tMaxZ = (stepZ > 0) ? (Math.floor(start.z) + 1 - start.z) * tDeltaZ : (start.z - Math.floor(start.z)) * tDeltaZ;
            let px = x, py = y, pz = z;
            const reach = 6.0, maxSteps = 50;
            for (let i = 0; i < maxSteps; i++) {
                const block = getBlock(x,y,z);
                if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                     const dist = Math.sqrt((x+0.5-start.x)**2 + (y+0.5-start.y)**2 + (z+0.5-start.z)**2);
                     if (dist > reach) return null;
                     return { x, y, z, px, py, pz, id: block };
                }
                px = x; py = y; pz = z;
                if (tMaxX < tMaxY) { if (tMaxX < tMaxZ) { x += stepX; tMaxX += tDeltaX; } else { z += stepZ; tMaxZ += tDeltaZ; } } else { if (tMaxY < tMaxZ) { y += stepY; tMaxY += tDeltaY; } else { z += stepZ; tMaxZ += tDeltaZ; } }
            }
            return null;
        }

        function placeBlock(hit) {
            const slot = inventory[selectedSlot];
            if (!slot || slot.count <= 0) return;
            const playerMinX = playerPos.x - PLAYER_RADIUS, playerMaxX = playerPos.x + PLAYER_RADIUS;
            const playerMinY = playerPos.y, playerMaxY = playerPos.y + PLAYER_HEIGHT;
            const blockMinX = hit.px, blockMaxX = hit.px + 1;
            const blockMinY = hit.py, blockMaxY = hit.py + 1;
            const blockMinZ = hit.pz, blockMaxZ = hit.pz + 1;
            const xOverlap = playerMaxX > blockMinX && playerMinX < blockMaxX;
            const yOverlap = playerMaxY > blockMinY && playerMinY < blockMaxY;
            const zOverlap = playerPos.z + PLAYER_RADIUS > blockMinZ && playerPos.z - PLAYER_RADIUS < blockMaxZ;
            if (xOverlap && yOverlap && zOverlap) return; 
            setBlock(hit.px, hit.py, hit.pz, slot.type);
            removeFromInventory();
        }

        function breakBlock(hit) {
            const type = getBlock(hit.x, hit.y, hit.z);
            if (type === BLOCKS.BEDROCK) return;
            setBlock(hit.x, hit.y, hit.z, BLOCKS.AIR);
            addToInventory(type);
            spawnParticles(hit);
            
            // WATER MECHANIC: Fill if next to water
            if (hit.y <= WATER_LEVEL) {
                const neighbors = [
                    getBlock(hit.x+1, hit.y, hit.z), getBlock(hit.x-1, hit.y, hit.z),
                    getBlock(hit.x, hit.y, hit.z+1), getBlock(hit.x, hit.y, hit.z-1),
                    getBlock(hit.x, hit.y+1, hit.z) // Water falls down
                ];
                if (neighbors.includes(BLOCKS.WATER)) {
                    // Delay slightly or set immediately
                    setBlock(hit.x, hit.y, hit.z, BLOCKS.WATER);
                }
            }
        }

        function checkCollision(pos) {
            const r = PLAYER_RADIUS;
            const h = PLAYER_HEIGHT;
            const points = [
                {x: pos.x - r, y: pos.y + 0.1, z: pos.z - r}, {x: pos.x + r, y: pos.y + 0.1, z: pos.z - r},
                {x: pos.x - r, y: pos.y + 0.1, z: pos.z + r}, {x: pos.x + r, y: pos.y + 0.1, z: pos.z + r},
                {x: pos.x - r, y: pos.y + h/2, z: pos.z - r}, {x: pos.x + r, y: pos.y + h/2, z: pos.z - r},
                {x: pos.x - r, y: pos.y + h/2, z: pos.z + r}, {x: pos.x + r, y: pos.y + h/2, z: pos.z + r},
                {x: pos.x - r, y: pos.y + h - 0.1, z: pos.z - r}, {x: pos.x + r, y: pos.y + h - 0.1, z: pos.z - r},
                {x: pos.x - r, y: pos.y + h - 0.1, z: pos.z + r}, {x: pos.x + r, y: pos.y + h - 0.1, z: pos.z + r}
            ];
            for(let p of points) {
                const b = getBlock(Math.floor(p.x), Math.floor(p.y), Math.floor(p.z));
                if(b !== BLOCKS.AIR && b !== BLOCKS.WATER) return true;
            }
            return false;
        }

        function isHeadInWater() {
            const block = getBlock(Math.floor(playerPos.x), Math.floor(playerPos.y + EYE_HEIGHT), Math.floor(playerPos.z));
            return block === BLOCKS.WATER;
        }
        function isFeetInWater() {
            const block = getBlock(Math.floor(playerPos.x), Math.floor(playerPos.y), Math.floor(playerPos.z));
            return block === BLOCKS.WATER;
        }

        function updateMining(dt) {
            const hit = raycast();
            if (hit) { highlightMesh.visible = true; highlightMesh.position.set(hit.x + 0.5, hit.y + 0.5, hit.z + 0.5); } else { highlightMesh.visible = false; }
            if (mouse.left) {
                if (!hit) { miningTime = 0; currentMineBlock = null; resetMiningUI(); return; }
                if (hit.id === BLOCKS.BEDROCK) { miningTime = 0; currentMineBlock = null; resetMiningUI(); return; }
                if (!currentMineBlock || hit.x !== currentMineBlock.x || hit.y !== currentMineBlock.y || hit.z !== currentMineBlock.z) { miningTime = 0; currentMineBlock = hit; }
                const hardness = BLOCK_HARDNESS[hit.id] || 1.0;
                miningTime += dt;
                const percent = Math.min(1, miningTime / hardness);
                const progressEl = document.getElementById('mining-progress');
                progressEl.style.opacity = 1;
                progressEl.style.background = `conic-gradient(white ${percent * 360}deg, transparent 0deg)`;
                if (Math.random() < 0.2) spawnParticles(hit);
                if (miningTime >= hardness) { breakBlock(hit); miningTime = 0; currentMineBlock = null; resetMiningUI(); }
            } else { resetMiningUI(); }
        }
        function resetMiningUI() { const el = document.getElementById('mining-progress'); el.style.opacity = 0; el.style.background = 'none'; }

        let prevTime = performance.now(), fpsFrames = 0, lastFpsTime = 0;
        
        // Hand Bobbing Logic
        let bobTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05);
            prevTime = time;
            updateWaterTexture();
            
            clouds.children.forEach(cloud => {
                cloud.position.x += delta * 2;
                if(cloud.position.x > 200) cloud.position.x = -200;
            });

            const headInWater = isHeadInWater();
            if (headInWater) {
                scene.background.copy(underwaterSkyColor); scene.fog.color.copy(underwaterFogColor); scene.fog.near = 0.5; scene.fog.far = 10;
                ambientLight.intensity = 0.1; dirLight.intensity = 0.05; sun.visible = false; moon.visible = false; clouds.visible = false;
            } else {
                timeOfDay += daySpeed * delta; if (timeOfDay > 1) timeOfDay -= 1;
                const phi = timeOfDay * Math.PI * 2; const sunX = Math.cos(phi) * 100; const sunY = Math.sin(phi) * 100; const sunZ = Math.sin(phi * 0.5) * 50; 
                const centerPos = inGame ? playerPos : menuCamera.position;
                sun.position.set(centerPos.x + sunX, centerPos.y + sunY, centerPos.z + sunZ);
                moon.position.set(centerPos.x - sunX, centerPos.y - sunY, centerPos.z - sunZ);
                clouds.position.set(centerPos.x, 0, centerPos.z);
                dirLight.position.copy(sun.position);
                const sunHeight = Math.sin(phi);
                dirLight.intensity = Math.max(0, sunHeight * 0.7); ambientLight.intensity = Math.max(0.15, sunHeight * 0.6 + 0.15);
                scene.background.lerpColors(nightSkyColor, daySkyColor, Math.max(0, sunHeight));
                scene.fog.color.lerpColors(nightFogColor, dayFogColor, Math.max(0, sunHeight));
                scene.fog.near = 10; scene.fog.far = (RENDER_DISTANCE * CHUNK_SIZE) - 5;
                sun.visible = true; moon.visible = true; clouds.visible = true;
            }

            if (!inGame) {
                menuCamera.position.set(0, 80, 0); menuCamera.rotation.y += 0.05 * delta; menuCamera.rotation.x = -0.2;
                updateChunks(); renderer.render(scene, menuCamera);
            } else if (controls.isLocked) {
                const inWater = isFeetInWater();
                const currentDrag = inWater ? WATER_DRAG : DRAG;
                const currentGravity = inWater ? WATER_GRAVITY : GRAVITY;
                const currentSpeed = inWater ? SWIM_SPEED : (keys.shift ? RUN_SPEED : WALK_SPEED);
                
                // Input Movement vector for bobbing check
                const moving = keys.w || keys.a || keys.s || keys.d;
                if(moving && onGround) {
                    bobTimer += delta * (keys.shift ? 18 : 12);
                    handMesh.position.x = 0.4 + Math.cos(bobTimer) * 0.02;
                    handMesh.position.y = -0.3 + Math.abs(Math.sin(bobTimer)) * 0.04;
                } else {
                    // Reset hand position smoothly
                    handMesh.position.x = THREE.MathUtils.lerp(handMesh.position.x, 0.4, delta * 10);
                    handMesh.position.y = THREE.MathUtils.lerp(handMesh.position.y, -0.3, delta * 10);
                }
                
                velocity.x -= velocity.x * currentDrag * delta; velocity.z -= velocity.z * currentDrag * delta; velocity.y -= currentGravity * delta;
                if (inWater) { if (keys.space) { velocity.y += SWIM_UP_FORCE * delta * 5; } else { if (playerPos.y < WATER_LEVEL) velocity.y += 15.0 * delta; } }
                const forward = new THREE.Vector3(); playerCamera.getWorldDirection(forward); forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(); right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
                if (keys.w) velocity.addScaledVector(forward, currentSpeed * delta);
                if (keys.s) velocity.addScaledVector(forward, -currentSpeed * delta);
                if (keys.d) velocity.addScaledVector(right, currentSpeed * delta);
                if (keys.a) velocity.addScaledVector(right, -currentSpeed * delta);
                const steps = 4; const subDelta = delta / steps; let groundedThisFrame = false;
                for(let s=0; s<steps; s++) {
                    const originalPos = playerPos.clone();
                    playerPos.x += velocity.x * subDelta; if(checkCollision(playerPos)) { playerPos.x = originalPos.x; velocity.x = 0; }
                    playerPos.z += velocity.z * subDelta; if(checkCollision(playerPos)) { playerPos.z = originalPos.z; velocity.z = 0; }
                    playerPos.y += velocity.y * subDelta; if(checkCollision(playerPos)) { const falling = velocity.y < 0; playerPos.y = originalPos.y; if (falling) { if (!onGround && !inWater) { const fallDist = highestY - playerPos.y; if (fallDist > 3.5) takeDamage(Math.floor((fallDist - 3) / 1.5)); } groundedThisFrame = true; highestY = playerPos.y; } velocity.y = 0; }
                }
                if (inWater) { const minPlayerY = WATER_LEVEL - EYE_HEIGHT + 0.01; if (playerPos.y < minPlayerY) { playerPos.y = minPlayerY; velocity.y = Math.max(0, velocity.y); } }
                if (!groundedThisFrame && onGround) { if (checkCollision(new THREE.Vector3(playerPos.x, playerPos.y - 0.1, playerPos.z))) { groundedThisFrame = true; } }
                onGround = groundedThisFrame;
                if (!onGround && !inWater && velocity.y < 0) { if (playerPos.y > highestY) highestY = playerPos.y; }
                if (playerPos.y < -30) takeDamage(10);
                if (keys.space && onGround && !inWater) { velocity.y = JUMP_FORCE; onGround = false; }
                playerCamera.position.x = playerPos.x; playerCamera.position.y = playerPos.y + EYE_HEIGHT; playerCamera.position.z = playerPos.z;
                updateMining(delta); updateParticles(delta); updateChunks();
                const hours = Math.floor(timeOfDay * 24); const minutes = Math.floor((timeOfDay * 24 * 60) % 60); const timeString = `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;
                document.getElementById('coords').innerText = `${Math.floor(playerPos.x)}, ${Math.floor(playerPos.y)}, ${Math.floor(playerPos.z)}`; document.getElementById('time').innerText = timeString;
                fpsFrames++; if(time - lastFpsTime > 1000) { document.getElementById('fps').innerText = fpsFrames; fpsFrames = 0; lastFpsTime = time; }
                renderer.render(scene, playerCamera);
            }
        }
        animate(); updateInventoryUI();
        window.addEventListener('resize', () => { const w = window.innerWidth; const h = window.innerHeight; playerCamera.aspect = w / h; playerCamera.updateProjectionMatrix(); menuCamera.aspect = w / h; menuCamera.updateProjectionMatrix(); renderer.setSize(w, h); });
    </script>
</body>
</html>
