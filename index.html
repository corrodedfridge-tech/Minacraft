<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minacraft</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Minecraft', 'Courier New', monospace;
            user-select: none;
        }
        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border: 2px solid white;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #mining-progress {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: white;
            opacity: 0;
        }

        #hud {
            position: absolute;
            bottom: 80px; 
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        #health-bar-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #333;
            display: flex;
        }
        
        .heart {
            flex: 1;
            background-color: #ff3333;
            margin: 1px;
            border: 1px solid #500;
        }
        .heart.lost {
            background-color: transparent;
            border: none;
        }
        
        #toolbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            background-color: rgba(0,0,0,0.3);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .slot.active {
            border-color: white;
            background-color: rgba(255,255,255,0.1);
        }
        .slot-icon {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Minacraft</h1>
        <p>Click to Start</p>
        <p>WASD to Move, SHIFT to Run, SPACE to Jump</p>
        <p>Hold Left Click to Mine</p>
        <p>Right Click to Build</p>
        <p>1-7 to select inventory slot</p>
        <p>Esc to pause</p>
        <p>Changelog: Player can't longer build on himself</p>
    </div>

    <div id="crosshair">
        <div id="mining-progress"></div>
    </div>
    
    <div id="health-bar-container" id="healthBar"></div>

    <div id="hud">
        FPS: <span id="fps">0</span><br>
        Coords: <span id="coords">0, 0, 0</span>
    </div>

    <div id="toolbar">
        <div class="slot active" id="slot0"></div>
        <div class="slot" id="slot1"></div>
        <div class="slot" id="slot2"></div>
        <div class="slot" id="slot3"></div>
        <div class="slot" id="slot4"></div>
        <div class="slot" id="slot5"></div>
        <div class="slot" id="slot6"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIG ---
        const CHUNK_SIZE = 16;
        const CHUNK_HEIGHT = 64; 
        const RENDER_DISTANCE = 3;
        
        // Physics Constants
        const WALK_SPEED = 20.0; 
        const RUN_SPEED = 35.0;
        const JUMP_FORCE = 11.0;
        const GRAVITY = 32.0;
        const DRAG = 8.0; 
        const PLAYER_RADIUS = 0.35;
        const PLAYER_HEIGHT = 1.8;
        const EYE_HEIGHT = 1.62;

        const BLOCKS = {
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, BEDROCK: 6
        };

        const BLOCK_HARDNESS = {
            [BLOCKS.GRASS]: 0.5, [BLOCKS.DIRT]: 0.5, [BLOCKS.STONE]: 1.2, 
            [BLOCKS.WOOD]: 0.8, [BLOCKS.LEAVES]: 0.2, [BLOCKS.BEDROCK]: Infinity
        };

        const TEXTURE_COLORS = {
            [BLOCKS.GRASS]: { top: '#5B8D37', side: '#4A6F28', bottom: '#6D4F35', display: '#5B8D37' },
            [BLOCKS.DIRT]: { all: '#6D4F35', display: '#6D4F35' },
            [BLOCKS.STONE]: { all: '#707070', display: '#707070' },
            [BLOCKS.WOOD]: { side: '#5C3A21', top: '#8B5A2B', bottom: '#8B5A2B', display: '#5C3A21' },
            [BLOCKS.LEAVES]: { all: '#3A6B29', display: '#3A6B29' },
            [BLOCKS.BEDROCK]: { all: '#222222', display: '#222222' }
        };

        // --- INVENTORY ---
        const INVENTORY_SIZE = 7;
        let inventory = Array(INVENTORY_SIZE).fill(null);
        let selectedSlot = 0;

        function updateInventoryUI() {
            for(let i=0; i<INVENTORY_SIZE; i++) {
                const el = document.getElementById('slot'+i);
                el.innerHTML = ''; 
                if (inventory[i]) {
                    const color = TEXTURE_COLORS[inventory[i].type].display;
                    const icon = document.createElement('div');
                    icon.className = 'slot-icon';
                    icon.style.backgroundColor = color;
                    
                    const count = document.createElement('div');
                    count.className = 'slot-count';
                    count.innerText = inventory[i].count;

                    el.appendChild(icon);
                    el.appendChild(count);
                }
                if (i === selectedSlot) el.classList.add('active');
                else el.classList.remove('active');
            }
        }

        function addToInventory(blockType) {
            for(let i=0; i<INVENTORY_SIZE; i++) {
                if(inventory[i] && inventory[i].type === blockType) {
                    inventory[i].count++;
                    updateInventoryUI();
                    return;
                }
            }
            for(let i=0; i<INVENTORY_SIZE; i++) {
                if(!inventory[i]) {
                    inventory[i] = { type: blockType, count: 1 };
                    updateInventoryUI();
                    return;
                }
            }
        }

        function removeFromInventory() {
            if (!inventory[selectedSlot]) return false;
            inventory[selectedSlot].count--;
            if (inventory[selectedSlot].count <= 0) inventory[selectedSlot] = null;
            updateInventoryUI();
            return true;
        }

        // --- HEALTH ---
        let maxHealth = 10;
        let currentHealth = 10;
        let highestY = 0;

        function initHealth() {
            const container = document.getElementById('health-bar-container');
            container.innerHTML = '';
            for(let i=0; i<maxHealth; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.id = 'heart-'+i;
                container.appendChild(heart);
            }
        }
        initHealth();

        function takeDamage(amount) {
            currentHealth = Math.max(0, currentHealth - amount);
            for(let i=0; i<maxHealth; i++) {
                const heart = document.getElementById('heart-'+i);
                if (i >= currentHealth) heart.classList.add('lost');
                else heart.classList.remove('lost');
            }
            document.body.style.boxShadow = "inset 0 0 50px red";
            setTimeout(() => document.body.style.boxShadow = "none", 200);

            if (currentHealth <= 0) {
                // Respawn
                playerPos.set(0, 50, 0);
                velocity.set(0,0,0);
                currentHealth = maxHealth;
                inventory = Array(INVENTORY_SIZE).fill(null);
                updateInventoryUI();
                initHealth();
            }
        }

        // --- WORLD GEN & NOISE ---
        class SimplexNoise {
            constructor() {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 0; i < 256; i++) {
                    const r = Math.floor(Math.random() * 256);
                    [this.p[i], this.p[r]] = [this.p[r], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }
            dot(g, x, y) { return g[0] * x + g[1] * y; }
            dot3(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
            noise2D(xin, yin) {
                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                let n0, n1, n2;
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                let i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii + this.perm[jj]] % 12;
                const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
                const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * this.dot(grad3[gi0], x0, y0); }
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * this.dot(grad3[gi1], x1, y1); }
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * this.dot(grad3[gi2], x2, y2); }
                return 70.0 * (n0 + n1 + n2);
            }
            // 3D Noise for Caves
            noise3D(x, y, z) {
                let n0, n1, n2, n3; 
                const F3 = 1.0/3.0;
                const s = (x+y+z)*F3;
                const i = Math.floor(x+s);
                const j = Math.floor(y+s);
                const k = Math.floor(z+s);
                const G3 = 1.0/6.0;
                const t = (i+j+k)*G3;
                const X0 = i-t;
                const Y0 = j-t;
                const Z0 = k-t;
                const x0 = x-X0;
                const y0 = y-Y0;
                const z0 = z-Z0;
                let i1, j1, k1;
                let i2, j2, k2;
                if(x0>=y0) {
                    if(y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0*G3;
                const y2 = y0 - j2 + 2.0*G3;
                const z2 = z0 - k2 + 2.0*G3;
                const x3 = x0 - 1.0 + 3.0*G3;
                const y3 = y0 - 1.0 + 3.0*G3;
                const z3 = z0 - 1.0 + 3.0*G3;

                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                
                // Helper to get gradient
                const getGrad = (ii,jj,kk) => grad3[this.perm[(ii&255)+this.perm[(jj&255)+this.perm[kk&255]]] % 12];

                let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                if(t0<0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * this.dot3(getGrad(i,j,k), x0, y0, z0); }

                let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                if(t1<0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * this.dot3(getGrad(i+i1,j+j1,k+k1), x1, y1, z1); }

                let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                if(t2<0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * this.dot3(getGrad(i+i2,j+j2,k+k2), x2, y2, z2); }

                let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                if(t3<0) n3 = 0.0;
                else { t3 *= t3; n3 = t3 * t3 * this.dot3(getGrad(i+1,j+1,k+1), x3, y3, z3); }

                return 32.0*(n0 + n1 + n2 + n3);
            }
        }

        function createTexture(colorStr) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorStr;
            ctx.fillRect(0, 0, 64, 64);
            for(let i=0; i<400; i++) {
                const x = Math.random() * 64;
                const y = Math.random() * 64;
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                ctx.fillRect(x, y, 2, 2);
            }
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.strokeRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, (RENDER_DISTANCE * CHUNK_SIZE) - 5);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        // Highlight Box (Wireframe) - OFFSET by 0.5 for new grid
        const highlightMesh = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.BoxGeometry(1.001, 1.001, 1.001)),
            new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
        );
        highlightMesh.visible = false;
        scene.add(highlightMesh);

        const controls = new PointerLockControls(camera, document.body);
        const ui = document.getElementById('ui');
        ui.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => ui.style.display = 'none');
        controls.addEventListener('unlock', () => ui.style.display = 'block');

        const materials = {};
        Object.keys(TEXTURE_COLORS).forEach(type => {
            const def = TEXTURE_COLORS[type];
            if(def.all) {
                materials[type] = new THREE.MeshLambertMaterial({ map: createTexture(def.all) });
            } else {
                materials[type] = [
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.top) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.bottom) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                    new THREE.MeshLambertMaterial({ map: createTexture(def.side) }),
                ];
            }
        });

        const noise = new SimplexNoise();
        const chunks = new Map(); 

        function getBlock(x, y, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const localX = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const key = `${cx},${cz}`;
            if (!chunks.has(key)) return BLOCKS.AIR;
            const chunk = chunks.get(key);
            if (y < 0 || y >= CHUNK_HEIGHT) return BLOCKS.AIR;
            return chunk.data[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
        }

        function setBlock(x, y, z, id) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const localX = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const key = `${cx},${cz}`;
            if (chunks.has(key)) {
                const chunk = chunks.get(key);
                if (y >= 0 && y < CHUNK_HEIGHT) {
                    chunk.data[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = id;
                    updateChunkGeometry(cx, cz);
                    if (localX === 0) updateChunkGeometry(cx - 1, cz);
                    if (localX === CHUNK_SIZE - 1) updateChunkGeometry(cx + 1, cz);
                    if (localZ === 0) updateChunkGeometry(cx, cz - 1);
                    if (localZ === CHUNK_SIZE - 1) updateChunkGeometry(cx, cz + 1);
                }
            }
        }

        function generateChunkData(cx, cz) {
            const data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT);
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const wx = cx * CHUNK_SIZE + x;
                    const wz = cz * CHUNK_SIZE + z;
                    
                    const n = noise.noise2D(wx / 50, wz / 50);
                    const surfaceHeight = Math.floor((n + 1) * 10) + 20;
                    
                    for (let y = 0; y < CHUNK_HEIGHT; y++) {
                        let isCave = false;
                        if (y > 0 && y < surfaceHeight - 5) {
                            const caveN = noise.noise3D(wx / 20, y / 20, wz / 20);
                            if (caveN < -0.4) isCave = true; 
                        }

                        let type = BLOCKS.AIR;
                        if (y === 0) type = BLOCKS.BEDROCK;
                        else if (isCave) type = BLOCKS.AIR; 
                        else if (y < surfaceHeight - 3) type = BLOCKS.STONE;
                        else if (y < surfaceHeight) type = BLOCKS.DIRT;
                        else if (y === surfaceHeight) type = BLOCKS.GRASS;
                        
                        data[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;
                    }
                    if (x > 2 && x < CHUNK_SIZE - 3 && z > 2 && z < CHUNK_SIZE - 3) {
                        if (Math.random() < 0.02) {
                            const h = surfaceHeight + 1;
                            if (data[x + z * CHUNK_SIZE + surfaceHeight * CHUNK_SIZE * CHUNK_SIZE] === BLOCKS.GRASS) {
                                for(let i=0; i<5; i++) {
                                    if(h+i < CHUNK_HEIGHT) data[x + z * CHUNK_SIZE + (h+i) * CHUNK_SIZE * CHUNK_SIZE] = BLOCKS.WOOD;
                                }
                                for(let lx=x-2; lx<=x+2; lx++) {
                                    for(let lz=z-2; lz<=z+2; lz++) {
                                        for(let ly=h+3; ly<=h+5; ly++) {
                                            if (ly >= CHUNK_HEIGHT) continue;
                                            const idx = lx + lz * CHUNK_SIZE + ly * CHUNK_SIZE * CHUNK_SIZE;
                                            if (data[idx] === BLOCKS.AIR) data[idx] = BLOCKS.LEAVES;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return data;
        }

        function updateChunkGeometry(cx, cz) {
            const key = `${cx},${cz}`;
            if (!chunks.has(key)) return;
            const chunk = chunks.get(key);
            const instances = {};
            const dummy = new THREE.Object3D();

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    for (let y = 0; y < CHUNK_HEIGHT; y++) {
                        const type = chunk.data[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
                        if (type === BLOCKS.AIR) continue;
                        const wx = cx * CHUNK_SIZE + x;
                        const wz = cz * CHUNK_SIZE + z;
                        const exposed = 
                            getBlock(wx+1, y, wz) === BLOCKS.AIR || getBlock(wx-1, y, wz) === BLOCKS.AIR ||
                            getBlock(wx, y+1, wz) === BLOCKS.AIR || getBlock(wx, y-1, wz) === BLOCKS.AIR ||
                            getBlock(wx, y, wz+1) === BLOCKS.AIR || getBlock(wx, y, wz-1) === BLOCKS.AIR;

                        if (exposed) {
                            if (!instances[type]) instances[type] = [];
                            // FIX: Add 0.5 to center geometry on integer grid like MC
                            dummy.position.set(wx + 0.5, y + 0.5, wz + 0.5);
                            dummy.updateMatrix();
                            instances[type].push(dummy.matrix.clone());
                        }
                    }
                }
            }
            const chunkGroup = new THREE.Group();
            Object.keys(instances).forEach(type => {
                const count = instances[type].length;
                if(count === 0) return;
                const mesh = new THREE.InstancedMesh(new THREE.BoxGeometry(1,1,1), materials[type], count);
                instances[type].forEach((mat, i) => mesh.setMatrixAt(i, mat));
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                chunkGroup.add(mesh);
            });
            if (chunk.mesh) scene.remove(chunk.mesh);
            chunk.mesh = chunkGroup;
            scene.add(chunkGroup);
        }

        function updateChunks() {
            const px = Math.floor(playerPos.x / CHUNK_SIZE);
            const pz = Math.floor(playerPos.z / CHUNK_SIZE);
            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const cx = px + x;
                    const cz = pz + z;
                    const key = `${cx},${cz}`;
                    if (!chunks.has(key)) {
                        chunks.set(key, { data: generateChunkData(cx, cz), mesh: null });
                        updateChunkGeometry(cx, cz);
                    }
                }
            }
            for (const [key, chunk] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - px) > RENDER_DISTANCE + 1 || Math.abs(cz - pz) > RENDER_DISTANCE + 1) {
                    if (chunk.mesh) scene.remove(chunk.mesh);
                    chunks.delete(key);
                }
            }
        }

        // --- PARTICLES ---
        const particleGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const particles = [];
        
        function spawnParticles(hit) {
            let color = '#888888';
            if (TEXTURE_COLORS[hit.id]) color = TEXTURE_COLORS[hit.id].display || TEXTURE_COLORS[hit.id].all;
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            const dx = hit.x - hit.px;
            const dy = hit.y - hit.py;
            const dz = hit.z - hit.pz;
            
            // Visuals at x.5, particles already match because raycast returns ints
            // but we need to match the new visual center.
            // Hit X is integer floor. Visual center is Hit X + 0.5.
            // Face offset logic:
            const baseX = hit.x + 0.5 - (dx * 0.5);
            const baseY = hit.y + 0.5 - (dy * 0.5);
            const baseZ = hit.z + 0.5 - (dz * 0.5);

            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(particleGeo, mat);
                mesh.position.set(
                    baseX + (Math.random()-0.5)*0.8,
                    baseY + (Math.random()-0.5)*0.8,
                    baseZ + (Math.random()-0.5)*0.8
                );
                
                mesh.userData = {
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5) * 4 + dx*2,
                        (Math.random() - 0.5) * 4 + dy*2,
                        (Math.random() - 0.5) * 4 + dz*2
                    ),
                    life: 0.5 + Math.random() * 0.3
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.life -= dt * 2;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                } else {
                    p.userData.vel.y -= 25 * dt;
                    p.position.addScaledVector(p.userData.vel, dt);
                    p.rotation.x += dt * 15;
                    p.scale.setScalar(p.userData.life);
                }
            }
        }

        const playerPos = new THREE.Vector3(0, 45, 0); 
        const velocity = new THREE.Vector3();
        let onGround = false;
        
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        let mouse = { left: false, right: false };
        let isMining = false;
        let miningTime = 0;
        let currentMineBlock = null;

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': keys.space = true; break;
                case 'ShiftLeft': keys.shift = true; break;
                case 'Digit1': selectedSlot = 0; updateInventoryUI(); break;
                case 'Digit2': selectedSlot = 1; updateInventoryUI(); break;
                case 'Digit3': selectedSlot = 2; updateInventoryUI(); break;
                case 'Digit4': selectedSlot = 3; updateInventoryUI(); break;
                case 'Digit5': selectedSlot = 4; updateInventoryUI(); break;
                case 'Digit6': selectedSlot = 5; updateInventoryUI(); break;
                case 'Digit7': selectedSlot = 6; updateInventoryUI(); break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
                case 'ShiftLeft': keys.shift = false; break;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            if (e.button === 0) { mouse.left = true; isMining = true; miningTime = 0; }
            if (e.button === 2) { const hit = raycast(); if (hit) placeBlock(hit); }
        });
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) { mouse.left = false; isMining = false; miningTime = 0; resetMiningUI(); }
        });

        function raycast() {
            const start = new THREE.Vector3(playerPos.x, playerPos.y + EYE_HEIGHT, playerPos.z);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            
            let x = Math.floor(start.x);
            let y = Math.floor(start.y);
            let z = Math.floor(start.z);

            const stepX = Math.sign(dir.x);
            const stepY = Math.sign(dir.y);
            const stepZ = Math.sign(dir.z);

            const tDeltaX = stepX !== 0 ? Math.abs(1 / dir.x) : Infinity;
            const tDeltaY = stepY !== 0 ? Math.abs(1 / dir.y) : Infinity;
            const tDeltaZ = stepZ !== 0 ? Math.abs(1 / dir.z) : Infinity;

            let tMaxX = (stepX > 0) ? (Math.floor(start.x) + 1 - start.x) * tDeltaX : (start.x - Math.floor(start.x)) * tDeltaX;
            let tMaxY = (stepY > 0) ? (Math.floor(start.y) + 1 - start.y) * tDeltaY : (start.y - Math.floor(start.y)) * tDeltaY;
            let tMaxZ = (stepZ > 0) ? (Math.floor(start.z) + 1 - start.z) * tDeltaZ : (start.z - Math.floor(start.z)) * tDeltaZ;

            let px = x;
            let py = y;
            let pz = z;

            const reach = 6.0;
            const maxSteps = 50;
            
            for (let i = 0; i < maxSteps; i++) {
                const block = getBlock(x,y,z);
                if (block !== BLOCKS.AIR) {
                     const dist = Math.sqrt((x+0.5-start.x)**2 + (y+0.5-start.y)**2 + (z+0.5-start.z)**2);
                     if (dist > reach) return null;
                     return { x, y, z, px, py, pz, id: block };
                }
                px = x; py = y; pz = z;
                if (tMaxX < tMaxY) {
                    if (tMaxX < tMaxZ) { x += stepX; tMaxX += tDeltaX; } else { z += stepZ; tMaxZ += tDeltaZ; }
                } else {
                    if (tMaxY < tMaxZ) { y += stepY; tMaxY += tDeltaY; } else { z += stepZ; tMaxZ += tDeltaZ; }
                }
            }
            return null;
        }

        function placeBlock(hit) {
            const slot = inventory[selectedSlot];
            if (!slot || slot.count <= 0) return;

            // Player Bounding Box Dimensions
            const playerMinX = playerPos.x - PLAYER_RADIUS;
            const playerMaxX = playerPos.x + PLAYER_RADIUS;
            const playerMinY = playerPos.y;
            const playerMaxY = playerPos.y + PLAYER_HEIGHT;
            
            // Proposed Block Bounding Box (always 1x1x1 at integer coordinates)
            const blockMinX = hit.px;
            const blockMaxX = hit.px + 1;
            const blockMinY = hit.py;
            const blockMaxY = hit.py + 1;
            const blockMinZ = hit.pz;
            const blockMaxZ = hit.pz + 1;
            
            // Intersection check on X, Y, and Z axes
            const xOverlap = playerMaxX > blockMinX && playerMinX < blockMaxX;
            const yOverlap = playerMaxY > blockMinY && playerMinY < blockMaxY;
            const zOverlap = playerPos.z + PLAYER_RADIUS > blockMinZ && playerPos.z - PLAYER_RADIUS < blockMaxZ;
            
            if (xOverlap && yOverlap && zOverlap) {
                // Collision detected: Prevent building inside the player's volume
                console.log("Placement blocked: Block intersects with player's bounding box.");
                return; 
            }

            setBlock(hit.px, hit.py, hit.pz, slot.type);
            removeFromInventory();
        }

        function checkCollision(pos) {
            const r = PLAYER_RADIUS;
            const h = PLAYER_HEIGHT;
            const points = [
                {x: pos.x - r, y: pos.y + 0.1, z: pos.z - r}, {x: pos.x + r, y: pos.y + 0.1, z: pos.z - r},
                {x: pos.x - r, y: pos.y + 0.1, z: pos.z + r}, {x: pos.x + r, y: pos.y + 0.1, z: pos.z + r},
                {x: pos.x - r, y: pos.y + h/2, z: pos.z - r}, {x: pos.x + r, y: pos.y + h/2, z: pos.z - r},
                {x: pos.x - r, y: pos.y + h/2, z: pos.z + r}, {x: pos.x + r, y: pos.y + h/2, z: pos.z + r},
                {x: pos.x - r, y: pos.y + h - 0.1, z: pos.z - r}, {x: pos.x + r, y: pos.y + h - 0.1, z: pos.z - r},
                {x: pos.x - r, y: pos.y + h - 0.1, z: pos.z + r}, {x: pos.x + r, y: pos.y + h - 0.1, z: pos.z + r}
            ];
            for(let p of points) {
                if(getBlock(Math.floor(p.x), Math.floor(p.y), Math.floor(p.z)) !== BLOCKS.AIR) return true;
            }
            return false;
        }

        function updateMining(dt) {
            const hit = raycast();
            if (hit) {
                highlightMesh.visible = true;
                highlightMesh.position.set(hit.x + 0.5, hit.y + 0.5, hit.z + 0.5);
            } else {
                highlightMesh.visible = false;
            }

            if (mouse.left) {
                if (!hit) { miningTime = 0; currentMineBlock = null; resetMiningUI(); return; }
                if (!currentMineBlock || hit.x !== currentMineBlock.x || hit.y !== currentMineBlock.y || hit.z !== currentMineBlock.z) {
                    miningTime = 0;
                    currentMineBlock = hit;
                }
                const hardness = BLOCK_HARDNESS[hit.id] || 1.0;
                miningTime += dt;
                const percent = Math.min(1, miningTime / hardness);
                const progressEl = document.getElementById('mining-progress');
                progressEl.style.opacity = 1;
                progressEl.style.background = `conic-gradient(white ${percent * 360}deg, transparent 0deg)`;

                if (Math.random() < 0.2) spawnParticles(hit);

                if (miningTime >= hardness) {
                    addToInventory(hit.id);
                    setBlock(hit.x, hit.y, hit.z, BLOCKS.AIR);
                    spawnParticles(hit);
                    miningTime = 0;
                    currentMineBlock = null; 
                    resetMiningUI();
                }
            } else {
                resetMiningUI();
            }
        }
        function resetMiningUI() {
            const el = document.getElementById('mining-progress');
            el.style.opacity = 0;
            el.style.background = 'none';
        }

        let prevTime = performance.now();
        let fpsFrames = 0;
        let lastFpsTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05);
            prevTime = time;

            if (controls.isLocked) {
                velocity.x -= velocity.x * DRAG * delta;
                velocity.z -= velocity.z * DRAG * delta;
                velocity.y -= GRAVITY * delta;

                const speed = keys.shift ? RUN_SPEED : WALK_SPEED;
                
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

                if (keys.w) velocity.addScaledVector(forward, speed * delta);
                if (keys.s) velocity.addScaledVector(forward, -speed * delta);
                if (keys.d) velocity.addScaledVector(right, speed * delta);
                if (keys.a) velocity.addScaledVector(right, -speed * delta);

                const steps = 4;
                const subDelta = delta / steps;
                
                // Initialize ground check for this frame
                let groundedThisFrame = false;

                for(let s=0; s<steps; s++) {
                    const originalPos = playerPos.clone();
                    
                    playerPos.x += velocity.x * subDelta;
                    if(checkCollision(playerPos)) {
                        playerPos.x = originalPos.x;
                        velocity.x = 0;
                    }

                    playerPos.z += velocity.z * subDelta;
                    if(checkCollision(playerPos)) {
                        playerPos.z = originalPos.z;
                        velocity.z = 0;
                    }

                    playerPos.y += velocity.y * subDelta;
                    if(checkCollision(playerPos)) {
                        const falling = velocity.y < 0;
                        playerPos.y = originalPos.y;
                        if (falling) {
                            if (!onGround) {
                                const fallDist = highestY - playerPos.y;
                                if (fallDist > 3.5) {
                                    const damage = Math.floor((fallDist - 3) / 1.5);
                                    if (damage > 0) takeDamage(damage);
                                }
                            }
                            groundedThisFrame = true; // Mark as grounded
                            highestY = playerPos.y;
                        }
                        velocity.y = 0;
                    }
                }
                
                // Secondary ground check for stability (prevents jitter when standing still)
                if (!groundedThisFrame && onGround) {
                    // Check for tiny floating distance, allowing jump
                    if (checkCollision(new THREE.Vector3(playerPos.x, playerPos.y - 0.1, playerPos.z))) {
                        groundedThisFrame = true;
                    }
                }
                
                onGround = groundedThisFrame;

                if (!onGround && velocity.y < 0) {
                     if (playerPos.y > highestY) highestY = playerPos.y;
                }
                
                if (playerPos.y < -30) takeDamage(10);
                
                if (keys.space && onGround) { velocity.y = JUMP_FORCE; onGround = false; }
                
                camera.position.x = playerPos.x;
                camera.position.y = playerPos.y + EYE_HEIGHT;
                camera.position.z = playerPos.z;

                updateMining(delta);
            }

            updateParticles(delta);
            updateChunks();
            document.getElementById('coords').innerText = `${Math.floor(playerPos.x)}, ${Math.floor(playerPos.y)}, ${Math.floor(playerPos.z)}`;
            fpsFrames++;
            if(time - lastFpsTime > 1000) { document.getElementById('fps').innerText = fpsFrames; fpsFrames = 0; lastFpsTime = time; }
            renderer.render(scene, camera);
        }

        animate();
        updateInventoryUI();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
